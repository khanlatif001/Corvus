#------------------------------------------------------------------------------
# Corvus specific control parameters (Corvus specific)
# Organize handler so that 
# 1. translation of generic to internal variables as much as possible.

target_list
% Space separated list with all the targets required for this calculation.
% 
{
|X| S ...
|X| ...
} .inp_target_list

title
% Title of this calculation.
{
This is a Corvus calculation |X| P
                             |X| ...
} .inp_title

scratch
% Directory for disk scratch for those Handlers that require large amounts of
% disk. If the directory is not present or it can not be created, Corvus reverts
% to the default.
% NOTE: This input variable is not fully implemented yet.
{
. |X| S ...
} .inp_scratch

# Adding the following input tag to facilitate the integration of the different
# versions of corvus. This will help the code run different wfs that could be
# provided by two codes. For example, both abinit and nwchem can produce
# dynamical matrices. This input tag allows us to choose which will be used by
# hand.
usehandlers
% Explicitely declare what Handlers are to be used in the generation of the
% Workflow. This helps the current simple Workflow generator when a given target
% is provided by more than one Handler.
% Current possible values are:
%    Feff, FeffRixs, Dmdw, Abinit, Vasp, Nwchem, Orca
{
|X| S ...
} .inp_usehandlers


#------------------------------------------------------------------------------
# General methodological control parameters

method
% Method used to compute the target. This variable is somewhat context-dependent
% and is ccurrently not fully implemented.
% Current possible values are:
%    dft, mp2, ccsd
{
dft |X| S
} .inp_method

xc
% Exchange-correlation functional to use if the "method" selected is "dft".
% Current possible values are:
%    lda, pbe, b3lyp
{
lda |X| S
} .inp_xc

pspfiles
% List of pseudopotentials for each atom in the system. Each line contains
% the label for the atoms (usually the element % name) and the name of the file
% with the pseudopotential. The required format for the files will depend on the
% Handler used.
{
|X| S S
|X| ...
} .inp_pspfil

scf_conv
% Convergence threshold for SCF cycles (HF, DFT, etc) in au. The value set by
% this variable might be internally overridden if the target requires tighter
% convergence settings.
{
1.0e-5|X| F
} .inp_scf_conv

keep_symm
% Toggle the preservation of initial symmetry in optimizations.
{
True |X| L
} .inp_keep_symm

constant_volume
% Keep the simulation cell volume constant in cell optimizations.
{
True |X| L
} .inp_constant_volume

nkpoints
% Define the number of k-point in each direction of the grid for reciprocal
% space simulations.
{
1 1 1 |X| I I I
} .inp_nkpoints

nqpoints
% Define the number of q-point perturbations in each direction of the grid for
% density functional perturbation theory (DFPT) simulations.
{
 |X| I I I
} .inp_nqpoints

pw_encut
% Planwave energy cutoff for reciprocal space simulations, in au.
{
15.0 |X| F
} .inp_ecut

#------------------------------------------------------------------------------
# Physical properties (generic by definition)

ismetal
% Toggle whether the system should be treated as a metal or as an insulator.
{
False |X| L
} .inp_ismetal

ene_int
# Internal (electronic) energy of the system, in au.
{
|X| F
} .inp_ene_int

cell_vectors
% Normalized simulation cell vector directions. These vectors are scaled using
% the "cell_scaling_iso" and "cell_scaling_abc" input variables to generate the
% simulation cell.
{
|X| F F F
|X| F F F
|X| F F F
} .inp_cell_vectors

cell_struc_opt_flags
% Toggle the optimization of the x, y and z coordinates of each atom in the
% system.
{
|X| L L L
|X| ...
} .inp_cell_struc_opt_flags

cell_struc_xyz_red
% Structure of the simulation cell in reduced coordinates if the system is
% extended and has periodic boundary conditions.
{
|X| S F F F
|X| ...
} .inp_cell_struc_xyz_red

cell_scaling_iso
% Unitless isotropic scaling of the unit cell.
{
1.0 |X| F
} .inp_cell_scaling_iso

cell_scaling_abc
% Scaling of the a, b an c axes of the simulation cell, in Angstroms.
{
|X| F F F
} .inp_cell_scaling_iso

mac_diel_const
% Approximate value of the macroscopic dielectric constant of the system used in
% some methods to accelerate convergence of the SCF cycle.
{
|X| F
} .inp_mac_diel_const

cluster
% Structure of the system is the system is not extended (i. e. is a molecule or
% cluster). The coordinates are in Angstroms.
{
|X| S F F F
|X| ...
} .inp_cluster

absorbing_atom
% Index of the absorbing atom for core spectroscopies such as XANES, EXAFS and
% XES.
{
 1 |X| I
} .inp_absorbing_atom

charge
% Net charge of the system.
{
0 |X| I
} .inp_charge

multiplicity
% Multiplicity of the system.
{
0 |X| I
} .inp_charge

spectral_broadening
% Broadening used in some spectroscopic methods.
{
0.0 |X| F
} .inp_spectral_broadening

#------------------------------------------------------------------------------
# Code specific control parameters

# Abinit
abinit.verbatim
% The content of this input variable is passed as is (i. e. "verbatim") into the
% input of all Abinit calculations, and it is meant to help with any Abinit
% input that is currently not implemented in Corvus. Thus, it should be used
% carfully to avoid inconsistencies with the automatically generated input.
% Users should refed to the Abinit manual for information on this extra input.
{
|X| P
} .inp_abinit.verbatim

abinit.ngqpt
% Equivalent to Abinit's ngqpt input variable: Defines the number of q-point
% perturbations in each direction of the grid for density functional
% perturbation theory (DFPT) simulations, and is that equivalent to the general
% "nqpoints" Corvus input variable. Please refer to the Abinit manual for
% further details.
%
% NOTE: This code-specific input variable will be replaced by the general
% "nqpoints" variable in the future.
{
|X| I I I
} .inp_abinit.ngqpt

abinit.ng2qpt
% Equivalent to Abinit's (anaddb) ng2qpt input variable: Defines the number of
% q-point perturbations in each direction of the finer grid for density
% functional perturbation theory (DFPT) simulations. Please refer to the
% Abinit manual for further details.
{
|X| I I I
} .inp_abinit.ng2qpt

#------------------------------------------------------------------------------

# NOTE: FDV
# Commenting this out. I have to find out a good definition for it and it is not
# currently being used.
#dmdw.mustar
#% Set the
#{
#|X| F
#} .inp_dmdw.mustar

#dmdw.ioflag
#{
#0 |X| I
#} .inp_dmdw.ioflag
dmdw.ioflag
% Set the amount of output printed by DMDW. Possible values are:
%   0: Terse, prints out only the desired result (s^2, u^2, etc).
%   1: Verbose, prints out the pole frequencies and weights, as well as
%      estimates of the Einstein temperatures for each path.
% Please refer to the DMDW section of the Feff manual for further details.
%
% NOTE: The current format described below is temporary for compatibility with
% previous versions of Corvus. This will be changed to "Integer" in the future.
{
|X| P
} .inp_dmdw.ioflag

#dmdw.nlanc
#{
#|X| I
#} .inp_dmdw.nlanc
dmdw.nlanc
% Set the number of Lanczos poles (i. e. iterations) in DMDW. Larger values
% usually improve convergence of the target quantity. However, the number of
% poles should not exceed the dimensions of the subspace spanned by the
% projection of the path into the appropriate eigenmodes of the Hessian. This
% means that this variable should always be less than 3*N-6, where N is the
% number of atoms in the system. In practice, a value of 6-8 is sufficient to
% obtain converged mean square relative displacements (MSRD, or s^2) for EXAFS.
% For crystallographic mean square displacements (MSD, or u^2) at least 16 poles
% are usually needed. Please refer to the DMDW section of the Feff manual for
% further details.
%
% NOTE: The current format described below is temporary for compatibility with
% previous versions of Corvus. This will be changed to "Integer" in the future.
{
|X| P
} .inp_dmdw.nlanc

dmdw.paths
% Set up the path descriptors that will generate the list of paths for which
% properties will be calculated. The list has the following form:
%   <Number of descriptors>
%     <Descriptor 1>
%     <Descriptor 2>
%    .
%    .
%
% Each descriptor has the form:
%   <Number of atoms in path> <Atom index 1> ... <Max. path length (Ang)>
%
% The atom indices can take the value 0 which acts as a wildcard for all atoms
% in the system.
%
% Examples:
%
% 2
% 2 1 0   3.0
% 3 2 0 5 6.0
%
% This section defines 2 paths descriptors. The first one generates all paths
% with two atoms, starting in atom 1 and going to all other atoms in the
% systems, but subject to a maximum effective path length of 3.0 Ang. The
% second one generates all paths with three atoms, starting in atom 2 and
% ending in atom 5, while passing trhough all other atoms in the system, but
% with a maximum effective length of 6.0 Ang.
% Using the same syntax atoms can be selected to compute their u^2. For example
% the paths section
%
% 1
% 1 0 0.0
%
% will produce u^2 for all atoms in the system. Please refer to the DMDW
% section of the Feff manual for further details.
%
% NOTE: The current format described below is temporary for compatibility with
% previous versions of Corvus.
{
|X| P
} .inp_dmdw.paths

#dmdw.tempgrid
#{
#|X| I F F
#} .inp_dmdw.tempgrid
dmdw.tempgrid
% Set up the temperature grid to compute the thermal properties in DMDW. It has
% the following form:
%
%   <Number of temperature> <Min. temp.> <Max. temp.>
%
% If the number of desired temperatures is just one, the maximum temperature
% input is not needed. Please refer to the DMDW section of the Feff manual for
% further details.
%
% NOTE: The current format described below is temporary for compatibility with
% previous versions of Corvus.
{
|X| P
} .inp_dmdw.tempgrid

#------------------------------------------------------------------------------

nwchem.basis
% Set the Gaussian basis set to be used in the NWChem calculations. The format
% is the same as in NWChem:
%
% <Atom label> <Basis set name>
%  .
%  .
%
% Please refer to the NWChem manual for further details.
{
|X| S ...
|X| ...
} .inp_nwchem.basis

nwchem.qmd.nstep_nucl
% Set the number of nuclear motion steps in a quantum MD simulation.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.qmd.nstep_nucl

nwchem.qmd.dt_nucl
% Set the time step for nuclear motion in a quantum MD simulation.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.qmd.dt_nucl

nwchem.qmd.targ_temp
% Set the target temperature in a quantum MD simulation.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.qmd.targ_temp

nwchem.qmd.thermostat
% Set the thermostat type to be used in a quantum MD simulation.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.qmd.thermostat

nwchem.qmd.print_xyz
% Toggle printing of xyz coordinates in a quantum MD simulation.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.qmd.print_xyz

nwchem.xc
% Set the exchange correlation potential for an NWChem DFT simulation.

% NOTE: This input variable will be superseded in the future by the more
% general "xc" variable.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.xc

nwchem.mult
% Set the multiplicity of the system for an NWChem DFT simulation.

% NOTE: This input variable will be superseded in the future by the more
% general "multiplicity" variable.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.mult

nwchem.qmd.snapstep
{
|X| S
} .inp_nwchem.qmd.snapstep

nwchem.xas.alpha
{
|X| S
} .inp_nwchem.xas.alpha

nwchem.xas.xrayenergywin
{
|X| F F
} .inp_nwchem.xas.xrayenergywin

nwchem.xas.nroots
{
|X| S
} .inp_nwchem.xas.nroots

nwchem.xas.vec
{
|X| S
} .inp_nwchem.xas.vec

nwchem.iter
{
|X| S
} .inp_nwchem.iter

nwchem.charge
% Set the net charge of the system for an NWChem DFT simulation.

% NOTE: This input variable will be superseded in the future by the more
% general "charge" variable.
%
% Please refer to the NWChem manual for further details.
{
|X| S
} .inp_nwchem.charge

nwchem.xaselem
{
|X| S
} .inp_nwchem.xaselem

#------------------------------------------------------------------------------

# FEFF input: Most of these will need to be changed due to the optional paramter
# that appear after the required parameters
feff.atoms
%
% ATOMS
% x1  y1  z1 ipot1
% x2  y2  z2 ipot2
% .
% .
% .
%
% Specify atomic positions in cartesian coordinates (in ˚Angstroms) and unique potential indices of
% each atom in the cluster, one atom per line. If the LATTICE card is used to define the unit
% cell for reciprocal space calculations, the ATOMS card lists the atoms in the unit cell. See the
% discussion of the POTENTIALS card and the COORDINATES card for more info on how to
% specify atom types and coordinates.
{
|X| F F F I
|X| ...
} .inp_feff.atoms

# HOLE
feff.hole
% DEPRICATED: Use EDGE card instead.
%
% HOLE ihole s02
%
% Specify the edge using the hole number ihole, e.g., 
% K-edge : ihole = 1
% L1-edge: ihole = 2
% s02 specifies the EXAFS amplitude reduction factor, and should be set to 1.
{
|X| I F
} .inp_feff.hole

# OVERLAP
feff.overlap
%
% OVERLAP ipot
%
% The OVERLAP card can be used to construct approximate overlapped atom potentials when
% atomic coordinates are not known or specified. If the atomic positions are listed following the
% ATOMS card, the OVERLAP card is not needed. feff9.6 will stop if both the ATOMS and
% OVERLAP cards are used. The OVERLAP card contains the potential index of the atom being
% overlapped and is followed by a list specifying the potential index, number of atoms of a given
% type to be overlapped and their distance to the atom being overlapped. The examples below
% demonstrate the use of an OVERLAP list. This option can be useful for initial single scattering
% XAFS calculations in complex materials where very little is known about the structure.
{
|X| I
} .inp_feff.overlap

# CONTROL
feff.control
%
% CONTROL ipot ixsph ifms ipaths igenfmt iff2x Standard
%
% The CONTROL card lets you run one or more of the feff program modules separately. There
% is a switch for each of six parts of feff : 0 means not to run that module, 1 means to
% run it. You can do the whole run in sequence, one module at a time, but you must run all
% modules sequentially. Do not skip modules: CONTROL 1 1 1 0 0 1 is incorrect. The default
% is CONTROL 1 1 1 1 1 1, i.e. run all 6 modules. ipot controls modules atomic, pot and screen;
% ifms controls modules fms and mkgtr; and iff2x controls modules ff2x, sfconv, and eels. The
% ldos module is not affected by the CONTROL card ; it is activated using the corresponding
% LDOS card.
{
|X| I I I I I I
} .inp_feff.control

# EXCHANGE
feff.exchange
{
|X| I F F I
} .inp_feff.exchange

# ION
feff.ion
{
|X| I F
|X| ...
} .inp_feff.ion

# TITLE
feff.title
{
|X| S ...
|X| ...
} .inp_feff.title

# FOLP
feff.folp
{
|X| I F
|X| ...
} .inp_feff.folp

# RPATH
feff.rpath
{
|X| F
} .inp_feff.rpath

# DEBYE
feff.debye
{
|X| F F I
} .inp_feff.debye

# Separate inp for DMDW
feff.dmdw
{
|X| S I I I
} .inp_feff.dmdw

# RMULT
feff.rmultiplier
{
|X| F
} .inp_feff.rmultiplier

# SS
feff.ss
{
|X| I I F F
|X| ...
} .inp_feff.ss

# PRINT
feff.print
{
|X| I I I I I I
} .inp_feff.print

#
# potentials: should have one more F at the end for spinph. Leaving that off for now.
feff.potentials
{
|X| I I S I I F
|X| ...
} .inp_feff.potentials

# NLEG
feff.nleg
{
|X| I
} .inp_feff.nleg

# CRITERIA
feff.criteria
{
|X| F F
} .inp_feff.criteria

# NOGEOM - leave out for now.
#feff.nogeom
#{
#.false. |X| L
#} .inp_feff.nogeom

# IORDER
feff.iorder
{
|X| I
} .inp_feff.iorder

# PCRITERIA
feff.pcriteria
{
|X| F F 
} .inp_feff.pcriteria

# SIG2
feff.sig2
{
|X| F
} .inp_feff.sig2

# XANES
feff.xanes
{
|X| F
} .inp_feff.xanes

# CORRECTIONS
feff.corrections
{
|X| F F
} .inp_feff.corrections

# AFOLP
feff.afolp
{
|X| F
} .inp_feff.afolp

# EXAFS
feff.exafs
{
|X| F F
} .inp_feff.exafs

# POLARIZATION
feff.polarization
{
|X| F F F
} .inp_feff.polarization

# ELLIPTICITY
feff.ellipticity
{
|X| F F F F
} .inp_feff.ellipticity

# RGRID
feff.rgrid
{
|X| F
} .inp_feff.rgrid

# RPHASES
feff.rphases
{
|X| L
} .inp_feff.rphases

# NSTAR
feff.nstar
{
|X| L
} .inp_feff.nstar

# NOHOLE
feff.nohole
{
|X| L
} .inp_feff.nohole

# SIG3
feff.sig3
{
|X| F F
} .inp_feff.sig3

# JUMPRM
feff.jumprm
{
|X| L
} .inp_feff.jumprm

# MBCONV
feff.mbconv
{
|X| L
} .inp_feff.mbconv 

# SPIN
feff.spin
{
|X| I F F F
} .inp_feff.spin

# EDGE
feff.edge
{
|X| S
} .inp_feff.edge

# SCF
feff.scf
{
|X| F I I F I
} .inp_feff.scf

# FMS
feff.fms
{
|X| F I I F F F
} .inp_feff.fms

# LDOS
feff.ldos
{
|X| F F F I
} .inp_feff.ldos

# INTERSTITIAL
feff.interstitial
{
|X| I F
} .inp_feff.interstitial

# CFAVERAGE
feff.cfaverage
{
|X| I I F
} .inp_feff.interstitial

# S02
feff.s02
{
|X| F
} .inp_feff.s02

# XES
feff.xes
{
|X| F F F
} .inp_feff.xes

# DANES
feff.danes
{
|X| F F F
} .inp_feff.danes

# FPRIME
feff.fprime
{
|X| F F F
} .inp_feff.fprime

# RSIGMA
feff.rsigma
{
|X| L
} .inp_feff.rsigma

# XMCD
feff.xmcd
{
|X| F F F
} .inp_feff.xmcd

# MULTIPOLES
feff.multipole
{
|X| I I
} .inp_feff.multipole

# UNFREEZEF
feff.unfreezef
{
|X| L
} .inp_feff.unfreezef

# TDLDA
feff.tdlda
{
|X| I
} .inp_feff.tdlda

# PMBSE
feff.pmbse
{
|X| I I I I
} .inp_feff.pmbse

# MPSE
feff.mpse
{
|X| I I
} .inp_feff.mpse

# SFCONV
feff.sfconv
{
|X| L
} .inp_feff.sfconv

# SELF
feff.self
{
|X| L
} .inp_feff.self

# SFSE
feff.sfse
{
|X| F
} .inp_feff.sfse

# RCONV
feff.rconv
{
|X| F S
} .inp_feff.rconv

# ELNES
feff.elnes
{
|X| F F F
|X| S
|X| ...
# In future, fix so that we actually have these params, not just strings.
} .inp_feff.elnes

# EXELFS
feff.exelfs
{
|X| F
|X| S
|X| ...
# In future, fix so that we actually have these params, not just strings.
} .inp_feff.exelfs

# MAGIC
feff.magic
{
|X| F
} .inp_feff.magic

# ABSOLUTE
feff.absolute
{
|X| L
} .inp_feff.absolute

# SYMMETRY
feff.symmetry
{
|X| L
} .inp_feff.symmetry

# REAL
feff.real
{
|X| L
} .inp_feff.real

# RECIPROCAL
feff.reciprocal
{
|X| L
} .inp_feff.reciprocal

# SGROUP
feff.sgroup
{
|X| L
} .inp_feff.sgroup

# LATTICE
feff.lattice
{
# Need to fix this so that all parameters are set in separate fields.
|X| S
|X| ...
} .inp_feff.lattice

# KMESH
feff.kmesh
{
|X| F ... 
} .inp_feff.kmesh

# STRFAC
feff.strfac
{
|X| F F F
} .inp_feff.strfac

# BANDSTRUCTURE
#feff.bandstructure
#{
# For future ...
#}

# COREHOLE
feff.corehole
{
|X| S
} .inp_feff.corehole

# TARGET
feff.target
{
|X| F
} .inp_feff.absorber

# EGRID
feff.egrid
{
|X| S F F F
|X| ...
} .inp_feff.egrid

# COORDINATES
feff.coordinates
{
|X| I
} .inp_feff.coordinates

# EXTPOT
feff.extpot
{
|X| L
} .inp_feff.extpot

# CHBROAD
feff.chbroad
{
|X| I
} .inp_feff.chbroad

# CHSH
feff.chsh
{
|X| I
} .inp_feff.chsh

# DIMS
feff.dims
{
|X| I I
} .inp_feff.dims

# NRIXS
feff.nrixs
{
|X| I 
|X| F ...
|X| ...
} .inp_feff.nrixs

# LJMAX
feff.ljmax
{
|X| I
} .inp_feff.ljmax

# LDEC
feff.ldec
{
|X| I
} .inp_feff.ldec

# SETEDGE
feff.setedge
{
|X| L
} .inp_feff.setedge

# EPS0
feff.eps0
{
|X| F
} .inp_feff.eps0

# OPCONS
feff.opcons
{
|X| L
} .inp_feff.opcons

# NUMDENS
feff.numdens
{
|X| I F
|X| ...
} .inp_feff.numdens

# PREPS
feff.preps
{
|X| L
} .inp_feff.preps

# EGAPSE
feff.egapse
{
|X| F
} .inp_feff.egapse

# CHWIDTH
feff.chwidth
{
|X| F
} .inp_feff.chwidth

# MDFF - will implement in future
#feff.mdff
#{
#|X| I 
#} .inp_feff.

# RESTART
feff.restart
{
|X| L
} .inp_feff.restart

# CONFIG
feff.config
{
|X| S
|X| ...
} .inp_feff.config

# SCREEN
feff.screen
{
# We will also want to improve this interface.
|X| S S
|X| ...
} .inp_feff.screen

# CIF
feff.cif
{
|X| S
} .inp_feff.cif

# EQUIVALENCE
feff.equivalence
{
|X| S
} .inp_feff.equivalence

# COMPTON
feff.compton
{
|X| F I I
} .inp_feff.compton

# RHOZZP 
feff.rhozzp
{
|X| L
} .inp_feff.rhozzp

# CGRID
feff.cgrid
{
|X| F I I I I
} .inp_feff.cgrid

# CORVAL
feff.corval
{
|X| F
} .inp_feff.corval

# SIGGK
feff.siggk
{
|X| F
} .inp_feff.siggk

# TEMPERATURE
feff.temperature
{
|X| F I
} .inp_feff.temperature

# DENSITY
feff.density
{
# den_type, grid_type, outfile
|X| S S S 
# origin
|X| F F F
# number of points in each direction
|X| I I I
# vectors along which to step
|X| F F F
|X| F F F
|X| F F F
} .inp_feff.density

# RIXS
feff.rixs
{
|X| F F F
} .inp_feff.rixs

# RLPRINT
feff.rlprint
{
|X| L
} .inp_feff.rlprint

# HUBBARD
feff.hubbard
{
|X| F F F I
} .inp_feff.hubbard

# CRPA
feff.crpa
{
|X| I F
} .inp_feff.crpa

# FULLSPECTRUM
feff.fullspectrum
{
|X| L
} .inp_feff.fullspectrum

# SCXC
feff.scxc
{
|X| I
} .inp_feff.scxc

#------------------------------------------------------------------------------
##############################################
#
#    ORCA 
#
##############################################
#
# Keywords - set multiple settings
# 
orca.scf.convergencestrategy
{
NormalConv |X| S
} .inp_orca.scf.convergencestrategy

orca.cpcm
{
|X| S
} .inp_orca.cpcm

# Method block input
#
orca.method.method
{
B3LYP |X| S
} .inp_orca.method.method

orca.method.runtype
{
OPT |X| S
} .inp_orca.method.runtype

orca.method.amass
{
Mass2016 |X| S
} .inp_orca.method.amass

orca.method.usesymm
{
F |X| L
} .inp_orca.method.usesymm

orca.method.frozencore
{
F |X| L
} .inp_orca.method.frozencore

orca.method.allowrhf
{
F |X| L
} .inp_orca.method.allowrhf

orca.method.ri
{
F |X| L
} .inp_orca.method.ri

orca.method.grid
{
GRID4 |X| S
} .inp_orca.method.grid

orca.method.gridx
{
|X| S
} .inp_orca.method.gridx


# SCF controls
orca.scf.hftyp
{
RHF |X| S
} .inp_orca.scf.hftyp

orca.scf.fracocc
{
|X| S
} .inp_orca.scf.fracocc

orca.scf.smeartemp
{
|X| L
} .inp_orca.scf.smeartemp

orca.scf.keepints
{
|X| L
} .inp_orca.scf.keepints

orca.scf.keepdens
{
|X| L
} .inp_orca.scf.keepdens

orca.scf.readints
{
|X| L
} .inp_orca.scf.readints

orca.scf.usecheapints
{
|X| L
} .inp_orca.scf.uescheapints

orca.scf.valformat
{
|X| S
} .inp_orca.scf.valformat


orca.scf.kmatrix
{
|X| S
} .inp_orca.scf.kmatrix

orca.scf.jmatrix
{
|X| S
} .inp_orca.scf.jmatrix

orca.scf.scfmode
{
|X| S
} .inp_orca.scf.scfmode

orca.scf.maxiter
{
|X| S
} .inp_orca.scf.maxiter

orca.scf.guess
{
|X| S
} .inp_orca.scf.guess

orca.scf.autostart
{
T |X| L
} .inp_orca.scf.autostart

orca.scf.convergence
{
NORMALSCF |X| S
} .inp_orca.scf.convergence

orca.scf.diis
{
|X| L
} .inp_orca.scf.diis

orca.scf.kdiis
{
|X| L
} .inp_orca.scf.kdiis

orca.scf.nr
{
|X| L
} .inp_orca.scf.nr

orca.scf.soscf
{
|X| L
} .inp_orca.scf.soscf

orca.scf.cnvdamp
{
|X| L
} .inp_orca.scf.cnvdamp

orca.scf.cnvshift
{
|X| L
} .inp_orca.scf.cnvshift

orca.scf.uno
{
|X| L
} .inp_orca.scf.uno



# Basis block
orca.basis.basis
{
def2-TZVP |X| S
} .inp_orca.basis.basis

orca.basis.decontract
{
|X| L
} .inp_orca.basis.decontract


# MP2 controls
orca.mp2
{
F |X| L
} .inp_orca.mp2

orca.mp2type
{
MP2 |X| S
} .inp_orca.mp2type

# Single reference CI controls (MDCI block)
orca.ci
{
F |X| L
} .inp_orca.ci

orca.citype
{
CCSD |X| S
} .inp_orca.citype

# GEOM block
orca.tole
{
|X| F
} .inp_orca.tole

orca.tolrmsg
{
|X| F
} .inp_orca.tolrmsg

orca.tolmaxg
{
|X| F
} .inp_orca.tolmaxg

orca.tolrmsd
{
|X| F
} .inp_orca.tolrmsd

orca.tolrmaxd
{
|X| F
} .inp_orca.tolrmaxd

orca.geom.optimizationquality
{
TIGHTOPT |X| S
} .inp_orca.geom.optimizationquality

# coordinate input block
orca.coords.units
{
|X| S
} .inp_orca.coords.units


# Relativistic options
orca.rel.method
{
|X| S
} .inp_orca.rel.method

orca.rel.soctype
{
|X| S
} .inp_orca.rel.soctype

# Output options
orca.output.printlevel
{
|X| S
} .inp_orca.output.printlevel

orca.output.print
{
|X| S
} .inp_orca.output.print

orca.output.xyzfile
{
|X| L
} .inp_orca.output.xyzfile

orca.output.pdbfile
{
|X| L
} .inp_orca.output.pdbfile

#------------------------------------------------------------------------------
# Original from SS

#nagrid
#{
#} .inp_nagrid

#ntemp
#{
#} .inp_ntemp

#temp
#{
#} .inp_temp


#dispopt
#{
#} .inp_dispopt

#ekopt
#{
#} .inp_ekopt

#ek
#{
#} .inp_ek

#edge
#{
#} .inp_edge

#s02
#{
#} .inp_s02

#control
#{
#} .inp_control

#print
#{
#} .inp_print

#ixc
#{
#} .inp_ixc

#scf
#{
#} .inp_scf

#spectrum
#{
#} .inp_spectrum

#kmax
#{
#} .inp_kmax

#rpath
#{
#} .inp_rpath

#debye
#{
#} .inp_debye

#debyetemp
#{
#    #Corvus:float
#} .inp_debyetemp

#dw_out
#{
#} .inp_dw_out

#dmdw_order
#{
#} .inp_dmdw_order

#dmdw_type
#{
#} .inp_dmdw_type

#dmdw_route
#{
#} .inp_dmdw_route

#elnes
#{
#} .inp_elnes

#egrid
#{
#} .inp_egrid

#lmax
#{
#} .inp_lmax

#natoms
#{
#|X| F F F
#} .inp_natoms

#ntypat
#{
#} .inp_ntypat

#typat
#{
#} .inp_typat

#znucl
#{
#} .inp_znucl

#xred
#{
#} .inp_xred

#acell
#{
#} .inp_acell

#rprim
#{
#} .inp_rprim
