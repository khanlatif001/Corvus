#------------------------------------------------------------------------------
# Corvus specific control parameters (Corvus specific)
# Organize handler so that 
# 1. translation of generic to internal variables as much as possible.

target_list
% Here we put stuff for doc
% doc line 1
% doc line 2
{
|X| S ...
|X| ...
} .inp_target_list

title
% Here here
% doc line 3
% doc line 4
{
This is a Corvus calculation |X| P
                             |X| ...
} .inp_title

scratch
{
. |X| S ...
} .inp_scratch

# Adding the following input tag to facilitate the integration of the different
# versions of corvus. This will help the code run different wfs that could be
# provided by two codes. For example, both abinit and nwchem can produce
# dynamical matrices. This input tag allows us to choose which will be used by
# hand.
usehandlers
{
|X| S ...
} .inp_usehandlers


#------------------------------------------------------------------------------
# General methodological control parameters

method
{
dft |X| S
} .inp_method

xc
{
pbe |X| S
} .inp_xc

pspfiles
{
|X| S S
|X| ...
} .inp_pspfil

scf_conv
{
|X| F
} .inp_scf_conv

keep_symm
{
|X| L
} .inp_keep_symm

constant_volume
{
|X| L
} .inp_constant_volume

nkpoints
{
1 1 1 |X| I I I
} .inp_nkpoints

nqpoints
{
 |X| I I I
} .inp_nqpoints

pw_encut
{
|X| F
} .inp_ecut

#------------------------------------------------------------------------------
# Physical properties (generic by definition)

# This variable sets wether the system is treated as a metal or insulator
ismetal
{
False |X| L
} .inp_ismetal

ene_int
{
|X| F
} .inp_ene_int

cell_vectors
{
|X| F F F
|X| F F F
|X| F F F
} .inp_cell_vectors

cell_opt_flags
{
|X| L L L
|X| ...
} .inp_cell_opt_flags

cell_struc_xyz_red
{
|X| S F F F
|X| ...
} .inp_cell_struc_xyz_red

cell_scaling_iso
{
|X| F
} .inp_cell_scaling_iso

cell_scaling_abc
{
|X| F F F
} .inp_cell_scaling_iso

mac_diel_const
{
|X| F
} .inp_mac_diel_const

cluster
{
|X| S F F F
|X| ...
} .inp_cluster

absorbing_atom
{
|X| I
} .inp_absorbing_atom


charge
{
0 |X| I
} .inp_charge

spectral_broadening
{
0.0 |X| F
} .inp_spectral_broadening
#------------------------------------------------------------------------------
# Code specific control parameters

# Abinit
abinit.verbatim
{
|X| P
} .inp_abinit.verbatim

abinit.ngqpt
{
|X| I I I
} .inp_abinit.ngqpt

abinit.ng2qpt
{
|X| I I I
} .inp_abinit.ng2qpt

dmdw.mustar
{
|X| F
} .inp_dmdw.mustar

#dmdw.ioflag
#{
#0 |X| I
#} .inp_dmdw.ioflag
dmdw.ioflag
{
|X| P
} .inp_dmdw.ioflag

#dmdw.nlanc
#{
#|X| I
#} .inp_dmdw.nlanc
dmdw.nlanc
{
|X| P
} .inp_dmdw.nlanc

dmdw.paths
{
|X| P
} .inp_dmdw.paths

#dmdw.tempgrid
#{
#|X| I F F
#} .inp_dmdw.tempgrid
dmdw.tempgrid
{
|X| P
} .inp_dmdw.tempgrid

nwchem.basis 
{
|X| S ...
|X| ...
} .inp_nwchem.basis

nwchem.qmd.nstep_nucl 
{
|X| S
} .inp_nwchem.qmd.nstep_nucl

nwchem.qmd.dt_nucl
{
|X| S
} .inp_nwchem.qmd.dt_nucl

nwchem.qmd.targ_temp
{
|X| S
} .inp_nwchem.qmd.targ_temp

nwchem.qmd.thermostat
{
|X| S
} .inp_nwchem.qmd.thermostat

nwchem.qmd.print_xyz
{
|X| S
} .inp_nwchem.qmd.print_xyz

nwchem.xc
{
|X| S
} .inp_nwchem.xc

nwchem.mult
{
|X| S
} .inp_nwchem.mult

nwchem.qmd.snapstep
{
|X| S
} .inp_nwchem.qmd.snapstep

nwchem.xas.alpha
{
|X| S
} .inp_nwchem.xas.alpha

nwchem.xas.xrayenergywin
{
|X| F F
} .inp_nwchem.xas.xrayenergywin

nwchem.xas.nroots
{
|X| S
} .inp_nwchem.xas.nroots

nwchem.xas.vec
{
|X| S
} .inp_nwchem.xas.vec

nwchem.iter
{
|X| S
} .inp_nwchem.iter

nwchem.charge
{
|X| S
} .inp_nwchem.charge

nwchem.xaselem
{
|X| S
} .inp_nwchem.xaselem

# FEFF input: Most of these will need to be changed due to the optional paramter
# that appear after the required parameters
feff.atoms
%
% ATOMS
% x1  y1  z1 ipot1
% x2  y2  z2 ipot2
% .
% .
% .
%
% Specify atomic positions in cartesian coordinates (in ËšAngstroms) and unique potential indices of
% each atom in the cluster, one atom per line. If the LATTICE card is used to define the unit
% cell for reciprocal space calculations, the ATOMS card lists the atoms in the unit cell. See the
% discussion of the POTENTIALS card and the COORDINATES card for more info on how to
% specify atom types and coordinates.
{
|X| F F F I
|X| ...
} .inp_feff.atoms

# HOLE
feff.hole
% DEPRICATED: Use EDGE card instead.
%
% HOLE ihole s02
%
% Specify the edge using the hole number ihole, e.g., 
% K-edge : ihole = 1
% L1-edge: ihole = 2
% s02 specifies the EXAFS amplitude reduction factor, and should be set to 1.
{
|X| I F
} .inp_feff.hole

# OVERLAP
feff.overlap
%
% OVERLAP ipot
%
% The OVERLAP card can be used to construct approximate overlapped atom potentials when
% atomic coordinates are not known or specified. If the atomic positions are listed following the
% ATOMS card, the OVERLAP card is not needed. feff9.6 will stop if both the ATOMS and
% OVERLAP cards are used. The OVERLAP card contains the potential index of the atom being
% overlapped and is followed by a list specifying the potential index, number of atoms of a given
% type to be overlapped and their distance to the atom being overlapped. The examples below
% demonstrate the use of an OVERLAP list. This option can be useful for initial single scattering
% XAFS calculations in complex materials where very little is known about the structure.
{
|X| I
} .inp_feff.overlap

# CONTROL
feff.control
%
% CONTROL ipot ixsph ifms ipaths igenfmt iff2x Standard
%
% The CONTROL card lets you run one or more of the feff program modules separately. There
% is a switch for each of six parts of feff : 0 means not to run that module, 1 means to
% run it. You can do the whole run in sequence, one module at a time, but you must run all
% modules sequentially. Do not skip modules: CONTROL 1 1 1 0 0 1 is incorrect. The default
% is CONTROL 1 1 1 1 1 1, i.e. run all 6 modules. ipot controls modules atomic, pot and screen;
% ifms controls modules fms and mkgtr; and iff2x controls modules ff2x, sfconv, and eels. The
% ldos module is not affected by the CONTROL card ; it is activated using the corresponding
% LDOS card.
{
|X| I I I I I I
} .inp_feff.control

# EXCHANGE
feff.exchange
{
|X| I F F I
} .inp_feff.exchange

# ION
feff.ion
{
|X| I F
|X| ...
} .inp_feff.ion

# TITLE
feff.title
{
|X| S ...
|X| ...
} .inp_feff.title

# FOLP
feff.folp
{
|X| I F
|X| ...
} .inp_feff.folp

# RPATH
feff.rpath
{
|X| F
} .inp_feff.rpath

# DEBYE
feff.debye
{
|X| F F I
} .inp_feff.debye

# Separate inp for DMDW
feff.dmdw
{
|X| S I I I
} .inp_feff.dmdw

# RMULT
feff.rmultiplier
{
|X| F
} .inp_feff.rmultiplier

# SS
feff.ss
{
|X| I I F F
|X| ...
} .inp_feff.ss

# PRINT
feff.print
{
|X| I I I I I I
} .inp_feff.print

#
# potentials: should have one more F at the end for spinph. Leaving that off for now.
feff.potentials
{
|X| I I S I I F
|X| ...
} .inp_feff.potentials

# NLEG
feff.nleg
{
|X| I
} .inp_feff.nleg

# CRITERIA
feff.criteria
{
|X| F F
} .inp_feff.criteria

# NOGEOM - leave out for now.
#feff.nogeom
#{
#.false. |X| L
#} .inp_feff.nogeom

# IORDER
feff.iorder
{
|X| I
} .inp_feff.iorder

# PCRITERIA
feff.pcriteria
{
|X| F F 
} .inp_feff.pcriteria

# SIG2
feff.sig2
{
|X| F
} .inp_feff.sig2

# XANES
feff.xanes
{
|X| F
} .inp_feff.xanes

# CORRECTIONS
feff.corrections
{
|X| F F
} .inp_feff.corrections

# AFOLP
feff.afolp
{
|X| F
} .inp_feff.afolp

# EXAFS
feff.exafs
{
|X| F F
} .inp_feff.exafs

# POLARIZATION
feff.polarization
{
|X| F F F
} .inp_feff.polarization

# ELLIPTICITY
feff.ellipticity
{
|X| F F F F
} .inp_feff.ellipticity

# RGRID
feff.rgrid
{
|X| F
} .inp_feff.rgrid

# RPHASES
feff.rphases
{
|X| L
} .inp_feff.rphases

# NSTAR
feff.nstar
{
|X| L
} .inp_feff.nstar

# NOHOLE
feff.nohole
{
|X| L
} .inp_feff.nohole

# SIG3
feff.sig3
{
|X| F F
} .inp_feff.sig3

# JUMPRM
feff.jumprm
{
|X| L
} .inp_feff.jumprm

# MBCONV
feff.mbconv
{
|X| L
} .inp_feff.mbconv 

# SPIN
feff.spin
{
|X| I F F F
} .inp_feff.spin

# EDGE
feff.edge
{
|X| S
} .inp_feff.edge

# SCF
feff.scf
{
|X| F I I F I
} .inp_feff.scf

# FMS
feff.fms
{
|X| F I I F F F
} .inp_feff.fms

# LDOS
feff.ldos
{
|X| F F F I
} .inp_feff.ldos

# INTERSTITIAL
feff.interstitial
{
|X| I F
} .inp_feff.interstitial

# CFAVERAGE
feff.cfaverage
{
|X| I I F
} .inp_feff.interstitial

# S02
feff.s02
{
|X| F
} .inp_feff.s02

# XES
feff.xes
{
|X| F F F
} .inp_feff.xes

# DANES
feff.danes
{
|X| F F F
} .inp_feff.danes

# FPRIME
feff.fprime
{
|X| F F F
} .inp_feff.fprime

# RSIGMA
feff.rsigma
{
|X| L
} .inp_feff.rsigma

# XMCD
feff.xmcd
{
|X| F F F
} .inp_feff.xmcd

# MULTIPOLES
feff.multipole
{
|X| I I
} .inp_feff.multipole

# UNFREEZEF
feff.unfreezef
{
|X| L
} .inp_feff.unfreezef

# TDLDA
feff.tdlda
{
|X| I
} .inp_feff.tdlda

# PMBSE
feff.pmbse
{
|X| I I I I
} .inp_feff.pmbse

# MPSE
feff.mpse
{
|X| I I
} .inp_feff.mpse

# SFCONV
feff.sfconv
{
|X| L
} .inp_feff.sfconv

# SELF
feff.self
{
|X| L
} .inp_feff.self

# SFSE
feff.sfse
{
|X| F
} .inp_feff.sfse

# RCONV
feff.rconv
{
|X| F S
} .inp_feff.rconv

# ELNES
feff.elnes
{
|X| F F F
|X| S
|X| ...
# In future, fix so that we actually have these params, not just strings.
} .inp_feff.elnes

# EXELFS
feff.exelfs
{
|X| F
|X| S
|X| ...
# In future, fix so that we actually have these params, not just strings.
} .inp_feff.exelfs

# MAGIC
feff.magic
{
|X| F
} .inp_feff.magic

# ABSOLUTE
feff.absolute
{
|X| L
} .inp_feff.absolute

# SYMMETRY
feff.symmetry
{
|X| L
} .inp_feff.symmetry

# REAL
feff.real
{
|X| L
} .inp_feff.real

# RECIPROCAL
feff.reciprocal
{
|X| L
} .inp_feff.reciprocal

# SGROUP
feff.sgroup
{
|X| L
} .inp_feff.sgroup

# LATTICE
feff.lattice
{
# Need to fix this so that all parameters are set in separate fields.
|X| S
|X| ...
} .inp_feff.lattice

# KMESH
feff.kmesh
{
|X| F ... 
} .inp_feff.kmesh

# STRFAC
feff.strfac
{
|X| F F F
} .inp_feff.strfac

# BANDSTRUCTURE
#feff.bandstructure
#{
# For future ...
#}

# COREHOLE
feff.corehole
{
|X| S
} .inp_feff.corehole

# TARGET
feff.target
{
|X| F
} .inp_feff.absorber

# EGRID
feff.egrid
{
|X| S F F F
|X| ...
} .inp_feff.egrid

# COORDINATES
feff.coordinates
{
|X| I
} .inp_feff.coordinates

# EXTPOT
feff.extpot
{
|X| L
} .inp_feff.extpot

# CHBROAD
feff.chbroad
{
|X| I
} .inp_feff.chbroad

# CHSH
feff.chsh
{
|X| I
} .inp_feff.chsh

# DIMS
feff.dims
{
|X| I I
} .inp_feff.dims

# NRIXS
feff.nrixs
{
|X| I 
|X| F ...
|X| ...
} .inp_feff.nrixs

# LJMAX
feff.ljmax
{
|X| I
} .inp_feff.ljmax

# LDEC
feff.ldec
{
|X| I
} .inp_feff.ldec

# SETEDGE
feff.setedge
{
|X| L
} .inp_feff.setedge

# EPS0
feff.eps0
{
|X| F
} .inp_feff.eps0

# OPCONS
feff.opcons
{
|X| L
} .inp_feff.opcons

# NUMDENS
feff.numdens
{
|X| I F
|X| ...
} .inp_feff.numdens

# PREPS
feff.preps
{
|X| L
} .inp_feff.preps

# EGAPSE
feff.egapse
{
|X| F
} .inp_feff.egapse

# CHWIDTH
feff.chwidth
{
|X| F
} .inp_feff.chwidth

# MDFF - will implement in future
#feff.mdff
#{
#|X| I 
#} .inp_feff.

# RESTART
feff.restart
{
|X| L
} .inp_feff.restart

# CONFIG
feff.config
{
|X| S
|X| ...
} .inp_feff.config

# SCREEN
feff.screen
{
# We will also want to improve this interface.
|X| S S
|X| ...
} .inp_feff.screen

# CIF
feff.cif
{
|X| S
} .inp_feff.cif

# EQUIVALENCE
feff.equivalence
{
|X| S
} .inp_feff.equivalence

# COMPTON
feff.compton
{
|X| F I I
} .inp_feff.compton

# RHOZZP 
feff.rhozzp
{
|X| L
} .inp_feff.rhozzp

# CGRID
feff.cgrid
{
|X| F I I I I
} .inp_feff.cgrid

# CORVAL
feff.corval
{
|X| F
} .inp_feff.corval

# SIGGK
feff.siggk
{
|X| F
} .inp_feff.siggk

# TEMPERATURE
feff.temperature
{
|X| F I
} .inp_feff.temperature

# DENSITY
feff.density
{
# den_type, grid_type, outfile
|X| S S S 
# origin
|X| F F F
# number of points in each direction
|X| I I I
# vectors along which to step
|X| F F F
|X| F F F
|X| F F F
} .inp_feff.density

# RIXS
feff.rixs
{
|X| F F F
} .inp_feff.rixs

# RLPRINT
feff.rlprint
{
|X| L
} .inp_feff.rlprint

# HUBBARD
feff.hubbard
{
|X| F F F I
} .inp_feff.hubbard

# CRPA
feff.crpa
{
|X| I F
} .inp_feff.crpa

# FULLSPECTRUM
feff.fullspectrum
{
|X| L
} .inp_feff.fullspectrum

# SCXC
feff.scxc
{
|X| I
} .inp_feff.scxc

##############################################
#
#    ORCA 
#
##############################################
#
# Keywords - set multiple settings
# 
orca.scf.convergencestrategy
{
NormalConv |X| S
} .inp_orca.scf.convergencestrategy

orca.cpcm
{
|X| S
} .inp_orca.cpcm

# Method block input
#
orca.method.method
{
B3LYP |X| S
} .inp_orca.method.method

orca.method.runtype
{
OPT |X| S
} .inp_orca.method.runtype

orca.method.amass
{
Mass2016 |X| S
} .inp_orca.method.amass

orca.method.usesymm
{
F |X| L
} .inp_orca.method.usesymm

orca.method.frozencore
{
F |X| L
} .inp_orca.method.frozencore

orca.method.allowrhf
{
F |X| L
} .inp_orca.method.allowrhf

orca.method.ri
{
F |X| L
} .inp_orca.method.ri

orca.method.grid
{
GRID4 |X| S
} .inp_orca.method.grid

orca.method.gridx
{
|X| S
} .inp_orca.method.gridx


# SCF controls
orca.scf.hftyp
{
RHF |X| S
} .inp_orca.scf.hftyp

orca.scf.fracocc
{
|X| S
} .inp_orca.scf.fracocc

orca.scf.smeartemp
{
|X| L
} .inp_orca.scf.smeartemp

orca.scf.keepints
{
|X| L
} .inp_orca.scf.keepints

orca.scf.keepdens
{
|X| L
} .inp_orca.scf.keepdens

orca.scf.readints
{
|X| L
} .inp_orca.scf.readints

orca.scf.usecheapints
{
|X| L
} .inp_orca.scf.uescheapints

orca.scf.valformat
{
|X| S
} .inp_orca.scf.valformat


orca.scf.kmatrix
{
|X| S
} .inp_orca.scf.kmatrix

orca.scf.jmatrix
{
|X| S
} .inp_orca.scf.jmatrix

orca.scf.scfmode
{
|X| S
} .inp_orca.scf.scfmode

orca.scf.maxiter
{
|X| S
} .inp_orca.scf.maxiter

orca.scf.guess
{
|X| S
} .inp_orca.scf.guess

orca.scf.autostart
{
T |X| L
} .inp_orca.scf.autostart

orca.scf.convergence
{
NORMALSCF |X| S
} .inp_orca.scf.convergence

orca.scf.diis
{
|X| L
} .inp_orca.scf.diis

orca.scf.kdiis
{
|X| L
} .inp_orca.scf.kdiis

orca.scf.nr
{
|X| L
} .inp_orca.scf.nr

orca.scf.soscf
{
|X| L
} .inp_orca.scf.soscf

orca.scf.cnvdamp
{
|X| L
} .inp_orca.scf.cnvdamp

orca.scf.cnvshift
{
|X| L
} .inp_orca.scf.cnvshift

orca.scf.uno
{
|X| L
} .inp_orca.scf.uno



# Basis block
orca.basis.basis
{
def2-TZVP |X| S
} .inp_orca.basis.basis

orca.basis.decontract
{
|X| L
} .inp_orca.basis.decontract


# MP2 controls
orca.mp2
{
F |X| L
} .inp_orca.mp2

orca.mp2type
{
MP2 |X| S
} .inp_orca.mp2type

# Single reference CI controls (MDCI block)
orca.ci
{
F |X| L
} .inp_orca.ci

orca.citype
{
CCSD |X| S
} .inp_orca.citype

# GEOM block
orca.tole
{
|X| F
} .inp_orca.tole

orca.tolrmsg
{
|X| F
} .inp_orca.tolrmsg

orca.tolmaxg
{
|X| F
} .inp_orca.tolmaxg

orca.tolrmsd
{
|X| F
} .inp_orca.tolrmsd

orca.tolrmaxd
{
|X| F
} .inp_orca.tolrmaxd

orca.geom.optimizationquality
{
TIGHTOPT |X| S
} .inp_orca.geom.optimizationquality

# coordinate input block
orca.coords.units
{
|X| S
} .inp_orca.coords.units


# Relativistic options
orca.rel.method
{
|X| S
} .inp_orca.rel.method

orca.rel.soctype
{
|X| S
} .inp_orca.rel.soctype

# Output options
orca.output.printlevel
{
|X| S
} .inp_orca.output.printlevel

orca.output.print
{
|X| S
} .inp_orca.output.print

orca.output.xyzfile
{
|X| L
} .inp_orca.output.xyzfile

orca.output.pdbfile
{
|X| L
} .inp_orca.output.pdbfile

#------------------------------------------------------------------------------
# Original from SS

#nagrid
#{
#} .inp_nagrid

#ntemp
#{
#} .inp_ntemp

#temp
#{
#} .inp_temp


#dispopt
#{
#} .inp_dispopt

#ekopt
#{
#} .inp_ekopt

#ek
#{
#} .inp_ek

#edge
#{
#} .inp_edge

#s02
#{
#} .inp_s02

#control
#{
#} .inp_control

#print
#{
#} .inp_print

#ixc
#{
#} .inp_ixc

#scf
#{
#} .inp_scf

#spectrum
#{
#} .inp_spectrum

#kmax
#{
#} .inp_kmax

#rpath
#{
#} .inp_rpath

#debye
#{
#} .inp_debye

#debyetemp
#{
#    #Corvus:float
#} .inp_debyetemp

#dw_out
#{
#} .inp_dw_out

#dmdw_order
#{
#} .inp_dmdw_order

#dmdw_type
#{
#} .inp_dmdw_type

#dmdw_route
#{
#} .inp_dmdw_route

#elnes
#{
#} .inp_elnes

#egrid
#{
#} .inp_egrid

#lmax
#{
#} .inp_lmax

#natoms
#{
#|X| F F F
#} .inp_natoms

#ntypat
#{
#} .inp_ntypat

#typat
#{
#} .inp_typat

#znucl
#{
#} .inp_znucl

#xred
#{
#} .inp_xred

#acell
#{
#} .inp_acell

#rprim
#{
#} .inp_rprim
